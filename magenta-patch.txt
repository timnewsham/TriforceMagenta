diff --git a/kernel/arch/arm64/arch.cpp b/kernel/arch/arm64/arch.cpp
index f687fa4..9ad687b 100644
--- a/kernel/arch/arm64/arch.cpp
+++ b/kernel/arch/arm64/arch.cpp
@@ -211,7 +211,9 @@ static void arm64_cpu_early_init(void)
     ARM64_WRITE_SYSREG(pmcntenset_el0, (1UL << 31));
 
     /* enable user space access to cycle counter */
+#ifdef THIS_BREAKS_TRIFORCE_QEMU
     ARM64_WRITE_SYSREG(pmuserenr_el0, 1UL);
+#endif
 
     /* enable user space access to virtual counter (CNTVCT_EL0) */
     ARM64_WRITE_SYSREG(cntkctl_el1, 1UL << 1);
diff --git a/kernel/lib/syscalls/syscalls.cpp b/kernel/lib/syscalls/syscalls.cpp
index d50efa6..01e0d9e 100644
--- a/kernel/lib/syscalls/syscalls.cpp
+++ b/kernel/lib/syscalls/syscalls.cpp
@@ -34,6 +34,7 @@ inline uint64_t invoke_syscall(
     uint64_t arg5, uint64_t arg6, uint64_t arg7, uint64_t arg8) {
     uint64_t ret;
 
+#ifdef nope
     const uintptr_t vdso_code_address =
         ProcessDispatcher::GetCurrent()->vdso_code_address();
     const uint64_t pc_offset = pc - vdso_code_address;
@@ -43,6 +44,9 @@ inline uint64_t invoke_syscall(
         if (unlikely(!VDso::ValidSyscallPC::name(pc_offset)))           \
             return sys_invalid_syscall(syscall_num, pc, vdso_code_address); \
     } while (0)
+#else
+#define CHECK_SYSCALL_PC(name) 
+#endif
 
     switch (syscall_num) {
 #include <magenta/syscall-invocation-cases.inc>
@@ -120,7 +124,7 @@ inline x86_64_syscall_result do_syscall(uint64_t syscall_num, uint64_t ip,
         ProcessDispatcher::GetCurrent()->vdso_code_address();
 
     uint64_t ret;
-    if (unlikely(!valid_pc(ip - vdso_code_address))) {
+    if (0 && unlikely(!valid_pc(ip - vdso_code_address))) {
         ret = sys_invalid_syscall(syscall_num, ip, vdso_code_address);
     } else {
         ret = make_call();
@@ -142,7 +146,9 @@ x86_64_syscall_result unknown_syscall(uint64_t syscall_num, uint64_t ip) {
     return do_syscall(syscall_num, ip,
                       [](uintptr_t) { return false; },
                       [&]() {
+#ifdef FUZZER_PATCH_MADE_THIS_REACHABLE
                           __builtin_unreachable();
+#endif
                           return ERR_INTERNAL;
                       });
 }
diff --git a/system/core/devmgr/devmgr.c b/system/core/devmgr/devmgr.c
index 79410f1..816f468 100644
--- a/system/core/devmgr/devmgr.c
+++ b/system/core/devmgr/devmgr.c
@@ -220,6 +220,7 @@ static mx_status_t block_device_added(int dirfd, int event, const char* name, vo
 }
 
 static const char* argv_sh[] = { "/boot/bin/sh" };
+static const char* argv_fuzzer[] = { "/boot/bin/fuzz", "-vv" };
 static const char* argv_autorun0[] = { "/boot/bin/sh", "/boot/autorun" };
 static const char* argv_init[] = { "/system/bin/init" };
 
@@ -310,8 +311,13 @@ static int console_starter(void* arg) {
     for (unsigned n = 0; n < 30; n++) {
         int fd;
         if ((fd = open("/dev/misc/console", O_RDWR)) >= 0) {
-            devmgr_launch(svcs_job_handle, "sh:console",
-                          countof(argv_sh), argv_sh, envp, fd, NULL, NULL, 0);
+            if(getenv("fuzz"))
+                devmgr_launch(svcs_job_handle, "fuzz:console",
+                            countof(argv_fuzzer), argv_fuzzer, envp, fd, NULL, NULL, 0);
+            else {
+                devmgr_launch(svcs_job_handle, "sh:console",
+                            countof(argv_sh), argv_sh, envp, fd, NULL, NULL, 0);
+            }
             break;
         }
         mx_nanosleep(mx_deadline_after(MX_MSEC(100)));
