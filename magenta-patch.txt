diff --git a/kernel/arch/arm64/arch.cpp b/kernel/arch/arm64/arch.cpp
index b22f29b..ccd7df5 100644
--- a/kernel/arch/arm64/arch.cpp
+++ b/kernel/arch/arm64/arch.cpp
@@ -210,7 +210,7 @@ static void arm64_cpu_early_init(void)
     ARM64_WRITE_SYSREG(pmcntenset_el0, (1UL << 31));
 
     /* enable user space access to cycle counter */
-    ARM64_WRITE_SYSREG(pmuserenr_el0, 1UL);
+    //ARM64_WRITE_SYSREG(pmuserenr_el0, 1UL);
 
     /* enable user space access to virtual counter (CNTVCT_EL0) */
     ARM64_WRITE_SYSREG(cntkctl_el1, 1UL << 1);
diff --git a/kernel/arch/x86/64/syscall.S b/kernel/arch/x86/64/syscall.S
index 16ed5e6..5d8948f 100644
--- a/kernel/arch/x86/64/syscall.S
+++ b/kernel/arch/x86/64/syscall.S
@@ -277,7 +277,7 @@ FUNCTION(x86_syscall)
     // pre_push and post_pop macros above to maintain alignment.
 #if WITH_LIB_SYSCALLS
     // Verify the syscall is in range and jump to it.
-    cmp     $MX_SYS_COUNT, %eax
+    cmp     $MX_SYS_COUNT, %rax
     jae     .Lunknown_syscall
     jmp     *.Lcall_wrapper_table(, %rax, 8)
 #include <magenta/syscall-kernel-branches.S>
diff --git a/kernel/dev/pcie/include/dev/pci_config.h b/kernel/dev/pcie/include/dev/pci_config.h
index 6ac7448..93c24da 100644
--- a/kernel/dev/pcie/include/dev/pci_config.h
+++ b/kernel/dev/pcie/include/dev/pci_config.h
@@ -76,7 +76,7 @@ public:
     static constexpr PciReg8 kInterruptPin = PciReg8(0x3D);
     static constexpr PciReg8 kMinGrant = PciReg8(0x3E);
     static constexpr PciReg8 kMaxLatency = PciReg8(0x3F);
-    static constexpr uint8_t kStdCfgEnd = kMaxLatency.offset() + sizeof(uint8_t);
+    static constexpr uint8_t kStdCfgEnd = static_cast<uint8_t>(kMaxLatency.offset() + sizeof(uint8_t));
 
     /* pci to pci bridge config
      * Unlike a normal PCI header, a bridge only has two BARs, but the BAR offset in config space
diff --git a/kernel/lib/syscalls/syscalls.cpp b/kernel/lib/syscalls/syscalls.cpp
index dda307a..f6c6836 100644
--- a/kernel/lib/syscalls/syscalls.cpp
+++ b/kernel/lib/syscalls/syscalls.cpp
@@ -34,6 +34,7 @@ inline uint64_t invoke_syscall(
     uint64_t arg5, uint64_t arg6, uint64_t arg7, uint64_t arg8) {
     uint64_t ret;
 
+#ifdef nope
     const uintptr_t vdso_code_address =
         ProcessDispatcher::GetCurrent()->vdso_code_address();
     const uint64_t pc_offset = pc - vdso_code_address;
@@ -43,6 +44,9 @@ inline uint64_t invoke_syscall(
         if (unlikely(!VDso::ValidSyscallPC::name(pc_offset)))           \
             return sys_invalid_syscall(syscall_num, pc, vdso_code_address); \
     } while (0)
+#else
+#define CHECK_SYSCALL_PC(name) 
+#endif
 
     switch (syscall_num) {
 #include <magenta/syscall-invocation-cases.inc>
@@ -123,7 +127,7 @@ inline x86_64_syscall_result do_syscall(uint64_t syscall_num, uint64_t ip,
         ProcessDispatcher::GetCurrent()->vdso_code_address();
 
     uint64_t ret;
-    if (unlikely(!valid_pc(ip - vdso_code_address))) {
+    if (0 && unlikely(!valid_pc(ip - vdso_code_address))) {
         ret = sys_invalid_syscall(syscall_num, ip, vdso_code_address);
     } else {
         ret = make_call();
@@ -141,11 +145,11 @@ inline x86_64_syscall_result do_syscall(uint64_t syscall_num, uint64_t ip,
     return {ret, thread_is_signaled(get_current_thread())};
 }
 
-inline x86_64_syscall_result unknown_syscall(uint64_t syscall_num, uint64_t ip) {
+x86_64_syscall_result unknown_syscall(uint64_t syscall_num, uint64_t ip) {
     return do_syscall(syscall_num, ip,
                       [](uintptr_t) { return false; },
                       [&]() {
-                          __builtin_unreachable();
+                          //__builtin_unreachable();
                           return ERR_INTERNAL;
                       });
 }
diff --git a/kernel/lib/syscalls/syscalls_test.cpp b/kernel/lib/syscalls/syscalls_test.cpp
index 14161d1..5eecc68 100644
--- a/kernel/lib/syscalls/syscalls_test.cpp
+++ b/kernel/lib/syscalls/syscalls_test.cpp
@@ -7,6 +7,7 @@
 #include "syscalls_priv.h"
 
 mx_status_t sys_syscall_test_0(void) {
+    panic("FUZZER PANIC TEST");
     return 0;
 }
 mx_status_t sys_syscall_test_1(int a) {
