diff --git a/kernel/arch/arm64/arch.cpp b/kernel/arch/arm64/arch.cpp
index f687fa4..9ad687b 100644
--- a/kernel/arch/arm64/arch.cpp
+++ b/kernel/arch/arm64/arch.cpp
@@ -211,7 +211,9 @@ static void arm64_cpu_early_init(void)
     ARM64_WRITE_SYSREG(pmcntenset_el0, (1UL << 31));
 
     /* enable user space access to cycle counter */
+#ifdef THIS_BREAKS_TRIFORCE_QEMU
     ARM64_WRITE_SYSREG(pmuserenr_el0, 1UL);
+#endif
 
     /* enable user space access to virtual counter (CNTVCT_EL0) */
     ARM64_WRITE_SYSREG(cntkctl_el1, 1UL << 1);
diff --git a/kernel/lib/syscalls/syscalls.cpp b/kernel/lib/syscalls/syscalls.cpp
index d50efa6..4f36475 100644
--- a/kernel/lib/syscalls/syscalls.cpp
+++ b/kernel/lib/syscalls/syscalls.cpp
@@ -34,6 +34,7 @@ inline uint64_t invoke_syscall(
     uint64_t arg5, uint64_t arg6, uint64_t arg7, uint64_t arg8) {
     uint64_t ret;
 
+#ifdef nope
     const uintptr_t vdso_code_address =
         ProcessDispatcher::GetCurrent()->vdso_code_address();
     const uint64_t pc_offset = pc - vdso_code_address;
@@ -43,6 +44,9 @@ inline uint64_t invoke_syscall(
         if (unlikely(!VDso::ValidSyscallPC::name(pc_offset)))           \
             return sys_invalid_syscall(syscall_num, pc, vdso_code_address); \
     } while (0)
+#else
+#define CHECK_SYSCALL_PC(name) 
+#endif
 
     switch (syscall_num) {
 #include <magenta/syscall-invocation-cases.inc>
@@ -120,7 +124,7 @@ inline x86_64_syscall_result do_syscall(uint64_t syscall_num, uint64_t ip,
         ProcessDispatcher::GetCurrent()->vdso_code_address();
 
     uint64_t ret;
-    if (unlikely(!valid_pc(ip - vdso_code_address))) {
+    if (0 && unlikely(!valid_pc(ip - vdso_code_address))) {
         ret = sys_invalid_syscall(syscall_num, ip, vdso_code_address);
     } else {
         ret = make_call();
@@ -142,7 +146,9 @@ x86_64_syscall_result unknown_syscall(uint64_t syscall_num, uint64_t ip) {
     return do_syscall(syscall_num, ip,
                       [](uintptr_t) { return false; },
                       [&]() {
+#ifndef FUZZER_PATCH_MADE_THIS_REACHABLE
                           __builtin_unreachable();
+#endif
                           return ERR_INTERNAL;
                       });
 }
diff --git a/kernel/lib/syscalls/syscalls_test.cpp b/kernel/lib/syscalls/syscalls_test.cpp
index 14161d1..5eecc68 100644
--- a/kernel/lib/syscalls/syscalls_test.cpp
+++ b/kernel/lib/syscalls/syscalls_test.cpp
@@ -7,6 +7,7 @@
 #include "syscalls_priv.h"
 
 mx_status_t sys_syscall_test_0(void) {
+    panic("FUZZER PANIC TEST");
     return 0;
 }
 mx_status_t sys_syscall_test_1(int a) {
